#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/homeImage.h" // image for HomeScreen
#include "images/endImage.h" // image for the EndScreen
#include "images/apple.h" // image of apple
#include "images/snakeIntro.h" // image for HomeScreen Animations
 
/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

struct snake Snake = {
  {80}, 
  {60}, 
  1,
  8,
  1,
  0,
  1
};

struct apple Apple = {
  1,
  100,
  60
};

struct animation Animations = {
  1,
  0,
  0,
  0
};

static int drawScreenEnd = 0;
static int drawScreenHome = 0;
static int counter = 0;

void placeApple(void) {
  Apple.appleX = randint(PLAY_AREA_X_MIN, PLAY_AREA_X_MAX - 8);
  Apple.appleY = randint(PLAY_AREA_Y_MIN, PLAY_AREA_Y_MAX - 8);
}

void clear(void) {
  Animations.animations = 0;
  Animations.oldanimationsX = 0;
  Animations.fpsCounter = 0;

  Snake.snakeLength = 1;
  Snake.snakeSpeed = 1;
  for (int i = 1; i < 100; i++) {  // Clear rest of snake
    Snake.snakeX[i] = 0;
    Snake.snakeY[i] = 0;
  }
  Snake.snakeX[0] = 80;
  Snake.snakeY[0] = 60;
  Snake.speedX = 1;
  Snake.speedY = 0;

}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE; // REG_DIPSCNT - main register for primary control of the screen & BG2_ENABLE - bit flag for REG_DISPCNT to enable Background 2

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        waitForVBlank();

        // avoid redrawing and tearing, so draw homescreen once
        if (!drawScreenHome) {
          drawImageDMA(0, 0, HOMEIMAGE_WIDTH, HOMEIMAGE_HEIGHT, homeImage);
          drawString(150, 45, "Press SELECT to Speed Up Snake", BLACK);
          drawScreenHome = 1;
        }
      
        // draws the play screen
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          clear();
          drawRectDMA(PLAY_AREA_Y_MIN, PLAY_AREA_X_MIN, PLAY_AREA_X_MAX - PLAY_AREA_X_MIN, PLAY_AREA_Y_MAX - PLAY_AREA_Y_MIN, WHITE);
          state = PLAY; 
          break;
        }

        // bonus animations on home screen
        if (Animations.fpsCounter == 180) {
          undrawImageDMA(0, Animations.oldanimationsX, SNAKEINTRO_WIDTH, SNAKEINTRO_HEIGHT, homeImage);
          drawImageDMA(0, Animations.animations, SNAKEINTRO_WIDTH, SNAKEINTRO_HEIGHT, snakeIntro);
          Animations.oldanimationsX = Animations.animations;
          Animations.animations += 10;
          if (Animations.animations > 240 - SNAKEINTRO_HEIGHT)
            Animations.animations = 0;
          Animations.fpsCounter = 0;
        } else {
          Animations.fpsCounter++;
        }
        break;

      case PLAY:
       waitForVBlank();

       // reset to home screen
       if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        drawScreenHome = 0;
        clear();
        counter = 0;
        state = START;
       }

       // controls the speed of the snake and the display of the speed on the screen
       if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        if (Snake.snakeSpeed <= 7) {
          Snake.snakeSpeed += 1;  
        }
        drawRectDMA(90, 4, 50, 8, BLACK); // draw Speed
        char strPrintSpeed[10];
        sprintf(strPrintSpeed, "Speed:%d", Snake.snakeSpeed);
        drawString(90, 4, strPrintSpeed, WHITE);
       }
      
       // draws the apple
       if (!Apple.appleExist) {
        int oldAppleX = Apple.appleX;
        int oldAppleY = Apple.appleY;
        placeApple();
        drawRectDMA(oldAppleY, oldAppleX, APPLE_WIDTH, APPLE_HEIGHT, WHITE); // cleans up old apple
        Apple.appleExist = 1;
       }
       drawImageDMA(Apple.appleY, Apple.appleX, APPLE_WIDTH, APPLE_HEIGHT, apple);

       // retrieve the tail coordinates of the snake
       int tailX = Snake.snakeX[Snake.snakeLength - 1];
       int tailY = Snake.snakeY[Snake.snakeLength - 1];

       // moves the snake in the direction by shifting in array
       for (int i = Snake.snakeLength - 1; i > 0; i--) {
        Snake.snakeX[i] = Snake.snakeX[i - 1];
        Snake.snakeY[i] = Snake.snakeY[i - 1];
       }

       // erase the end of the snake so does not leave behind a trail
       drawRectDMA(tailY, tailX, Snake.snakeSize, Snake.snakeSize, WHITE);

       // adjust the speed of the snake based on the user input
       Snake.snakeX[0] += (Snake.snakeSpeed * Snake.speedX);
       Snake.snakeY[0] += (Snake.snakeSpeed * Snake.speedY);

       // draws the snake
       for (int i = 0; i < Snake.snakeLength; i++) {
        drawRectDMA(Snake.snakeY[i], Snake.snakeX[i], Snake.snakeSize, Snake.snakeSize, GREEN);
       }

       // check collision with apple
       if (Snake.snakeX[0] < Apple.appleX + 8 && Snake.snakeX[0] + 8 > Apple.appleX && Snake.snakeY[0] < Apple.appleY + 8 && Snake.snakeY[0] + 8 > Apple.appleY) {
        Apple.appleExist = 0;
        ++counter;

        drawRectDMA(56, 1, 60, 8, BLACK); // draw # of Apples
        char strPrint[10];
        sprintf(strPrint, "Apples:%d", counter);
        drawString(56, 2, strPrint, WHITE);

        // increases the length of the snake
        Snake.snakeX[Snake.snakeLength] = Snake.snakeX[Snake.snakeLength - 1];
        Snake.snakeY[Snake.snakeLength] = Snake.snakeY[Snake.snakeLength - 1];

        Snake.snakeLength++;
       }
   
       // handle input for movement
       if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
           Snake.speedX = 1;
           Snake.speedY = 0;
       }
       if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
           Snake.speedX = -1;
           Snake.speedY = 0;
       }
       if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
           Snake.speedX = 0;
           Snake.speedY = -1;
       }
       if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
           Snake.speedX = 0;
           Snake.speedY = 1;
       }
   
       // handle collision with boundaries (lose state)
       if (Snake.snakeX[0] <= PLAY_AREA_X_MIN || Snake.snakeX[0] + 8 >= PLAY_AREA_X_MAX ||
        Snake.snakeY[0] <= PLAY_AREA_Y_MIN || Snake.snakeY[0] + 8 >= PLAY_AREA_Y_MAX) {
        Snake.snakeX[0] = 80;
        Snake.snakeY[0] = 60;
        clear();
        state = LOSE;
       }

       // win state
       if (Snake.snakeLength == 31) {
        state = WIN;
       }

       break;

      case WIN:
        waitForVBlank();

        // make sure that do not draw more than once (reduce tearing)
        if (!drawScreenEnd) {
          waitForVBlank();
          drawImageDMA(0, 0, ENDIMAGE_WIDTH, ENDIMAGE_HEIGHT, endImage);
          drawString(80, 30, "CONGRATULATIONS, YOU WIN", BLACK);

          char strPrint[10];
          sprintf(strPrint, "Score:%d", counter);
          drawString(90, 30, strPrint, WHITE);
          counter = 0;
          drawScreenEnd = 1;
          clear();
        }
    
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          counter = 0;
          drawScreenEnd = 0;
          drawScreenHome = 0;
          clear();
          state = START;
        }
   
        break;
      case LOSE:
        waitForVBlank();

        if (!drawScreenEnd) {
          waitForVBlank();
          drawImageDMA(0, 0, ENDIMAGE_WIDTH, ENDIMAGE_HEIGHT, endImage);
          drawString(80, 40, "BETTER LUCK NEXT TIME", BLACK);

          char strPrint[10];
          sprintf(strPrint, "Score:%d", counter);
          drawString(90, 40, strPrint, WHITE);
          counter = 0;
          drawScreenEnd = 1;
          clear();
        }
    
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            counter = 0;
            drawScreenEnd = 0;
            drawScreenHome = 0;
            clear();
            state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
